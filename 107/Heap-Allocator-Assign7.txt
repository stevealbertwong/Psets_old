
/* 15-231 malloc recitation */

1. Marcos:

DEFIN:
Marcos - mechanism in c before program gets compiled could do find and replace
e.g. 
#DEFINE NUM_ENTRIES 100 // define constant 
#DEFINE twice(x) (2*(x)) // define simple operation or function, wrap in () since naive search and replace


USAGE:
- faster than function calls -> since NO call queue, calling conventions with function calls: moving stuff into register, jump, stack pointer, when we are done undo all of that jump back to where we were before. 
- search and replace -> allows us to updates all occurence at once.
- e.g. macros ideal way for quick access to header information (payload size, valid, keep track of blocks of memory freed)


2.Inline function:

DEFIN:
Inline an existing function -> at compile time replaces function calls with code-> so no need to do stack conventions as it is not making a call
add inline at the beginning of the function

USAGE:
- getting full benefit of type checked arguments
- useful for functions that are called frequently 
 


3. Pointer review:
i.e. casting, dereferencing, arithmetic

CASTING:
Casting from pointer type a to pointer type b

Casting from pointer type a to int/unsigned int 

- all pointers are 8 types long interger in 64 bits system
- just changing the intepretation what kind of pointer it is
 
??? writing pointer into location as number you are manipulating 
contructing pointer directly by doing arithmetic on them

POINTER ARITHMETIC
- pointer + 1 -> address of the pointer + 1*size of the pointer type 
e.g. 
int* pointer = something;
(void*) pointer2 = (void*) (pointer+2);
this is really computing -> pointer2 = pointer + (2*sizeof(int));
in assembly -> lea (i.e. load effective address) lea (pointer, a, sizeof(int)), pointer2;

 



/* 107 heap allocator summary 
Design and implement the malloc, realloc, free, validate_heap, init and provide their interface as the standard libc allocator

*/

TASKS:
1. Error handling 
- e.g. realloc stack addresses, free already freed pointer, overruns the end of allocated block
- respond by crashing or corrupting heap
- name mymalloc, myrealloc, myfree -> avoid crushing  

2. Size of allocated block
- INT_MAX bytes to limit maximum request size, if requested allocate block larger than maximum size -> return NULL
- ALIGNMENT contant (8) 
- every alllocated block must be aligned to an address that is a multiple of ALIGNMENT CONSTANT

3. Segment.h
- heap segment is a large contiguous region of memory obtained from OS

AFTER RANDOM SEARCH ON GITHUB, I IMAGINE segment.h and segment.c look like this

// does all malloc for segments
- segments_alloc(long length, long minNum): 
create typedef struct segments{length, minNum, *vectorContentPtr, **strings} named segmentsPtr
segmentsPtr = (segments_t*)malloc(sizeof(segments_t));
segmentsPtr->strings = (char**)malloc(minNum * sizeof(char*)); //preallocate minNum of segments
string = (char*)malloc(minNum * (length+1) * sizeof(char)); //malloc string
segmentPtr->string[i] = &string[i*(length+1)] // populating segmentPtr -> stringPtr with string contents
segmentPtr->contentsPtr = vector_alloc(minNum);

//populates contentPtr
- segments_create
- segments_free

4. Static Global Data/Variable
- limited to 500 bytes for heap housing keeping
- store in heap segment	
- e.g. block header/footer, data structure  
- throughput counts the number of requests serviced per second 
- utilization -> if 100 blocks fo size 32 is allocated and heap segment is size of one page 4k, utilization ratio is 32*100/4096 = 78%


 
 
 
