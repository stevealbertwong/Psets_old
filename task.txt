>70: Stanford, MIT, Cal
63: Caltec, Carneige Mellon, Princeton, Harvard
56: Columbia, Cornell, UPenn, Maryland, Michigan, Georgia Tech, Waterloo
51: UChicago, UT, Washington, UIUC, UCLA, RIT, Harvey Mudd, Middlebury
47: Northwestern, Duke, JohnHopkins, UVA, Vanderbilt, USC, Lehigh, UCSD, Rugters
42: UMassAmherst, UNC, Buffalo, Davis, Arizona, Florida, Purdue, Stony Brook
35: Temple, Penn State, Drexel, Worcester Polytech, Virginia Tech, College of New Jersey, New Jersey Institute of Technology, SMU, UT Dallas, Binghamton  

>10: A+
9: A
8: A-
7: B+
6: B
5: B-


INTRO
cs103 4 weeks
cs41 2 weeks
cs106a 2 weeks
cs106b 3 weeks
cs106l 2 weeks
cs106x 2 weeks
cs108 3 weeks
cs109 4 weeks

SYSTEM:
cs1u 1 week
cs107 4 weeks 
cs110 4 weeks 
cs140 6 weeks 
cs240 4 weeks
cs144 4 week
cs244 4 weeks
cs155 4 weeks

DATA STRUCTURE
cs161 4 weeks
cs261 4 weeks
cs166 4 weeks
cs168 4 weeks
cs167 4 weeks
cs267 4 weeks

MACHINE LEARNING
cs228 4 weeks
cs221 4 weeks
Math51 4 weeks
cs229 4 weeks
cs231n 4 weeks
cs224d 3 weeks
cs224u 3 weeks
cs224n 3 weeks
Convex Optimization 5 weeks

MOBILE AND WEB
cs193p 4 weeks
cs193a 3 weeks
cs142 3 weeks

OTHERS
cs124
cs246 4 weeks
cs224w
21 months


Agile Development: 
-1 hour work = 1 pt

5-28: 
Read up assign7 -> 4 pts
Read up CMU malloclab ->2 pts

5-29:
mycodeschool pointer arithmetic, type casting, void pointer -> 2 pts
Learn C pointers and struct and data structure -> 2 pts
mycodeschool malloc, realloc, calloc, free() -> 3 pts

5-30:
finish up malloc recitiation ->3 pts
starting reading on 110 mapreduce -> 1pt

5-31:
reading 110 mapreduce-server.cc -> 3 pts
MapReduceServer Class 
unsigned long extractPortNumber(const char* portArgument)
void initializeFromConfigFile(const std::string& configFilename)
void applyToServer(const std::string& key, const std::string& value)
std::string ensureDirectoryExists(const std::string& key, const std::string& path)

6-1:
110 mapreduce-server.cc
buildIPAddressMap ->1pt

6-2:
106b LinkedList::add, get, insert - 3pts

6-3:
15-213 Virtual Memory6-3:

6-4: 
106b BinaryTree::print, contains - 2pts
110 int createServerSocket(unsigned short port, in backlog) - 1pt

6-5:
learn c ex18 function pointer as callback -1pt
typedef int (*compare_callback)(int a, int b);
int* bubble_sort(int a, int b, compare_callback c){
	if c(a, b)>0{
	do something..}
};
 
106b file/io ifstream getline(input, file), open(), close()- 1pt

6-6:
makefile, files settings dependencies, libraries -2pts
command make reads in the file Makefile from current directory
make reassemble, make myprogram, make clean -> build specific target 
gcc main.cc function1.cc function2.cc -o hello

109 - pset5 titanic + estimating parameter -3pts
import csv
open("titanic.csv") as csvfile
readCSV= csv.reader(csvfile, delimiter=",")
for row in readCSV // go through each row
	if (row[3] == "w" && row[1] == "1") // go through each item in the row to get woman in first class
		women1stClass++
		if  (row[0] == 1)
			survived ++
p = survived / women1stClass

6-7
109 parameter estimation, method of moments applied on poisson, bernoulli, normal, uniform distribution - 2pts
106b FirstProgram.cpp HamDaDaDa.cpp -3pts 
using namespace std = std::cout 
C++ - #include<iostream>, no public private static shit in c++
java - printl("Hello" + "world); #import, public static int main();
c++ - std::cout<< "hello" << "world" << std::endl // standard console output, pacman you are eating the output or less than less than, <<endl if not written then cursor just stay in the same line  
c - printf
getline();
int main() return 0 -> C++ the int goes out to operating system whether program has executed or not, in java main is void 
parametr sends information into method

wget download all index on apache website-> 1pt

6-8
Matrix review - reduce echelon form, LU factorization, linearly dependent, inverse, diagonal, upper triangular, gaussian elimination, homogeneous system with trivial solution, generic system, augmented matrix, rank of matrix, gauss-jordan elimination - 1pt

Google Developer tool https://www.youtube.com/watch?v=G74ll-6L4_o - 3pts
element, networking, resources, console
JS DataStructure and Algo - 1pt
143 coursera -1pt

6-9
VM setup but no login in page, repair file system error- 1pt
CSE 351 data lab - 1pt
351 lab0 -1pt
351 hardware organization, electronic implementation of bits, one memory address correspond to each byte of memory,8 bytes are going ot group tgt to represent 64 bit addressfor x86 machine, address is the first byte of grouped address, 64bits represents word size of the machine/integer size, so we could have 8 gbs different addresses,  
little vs big endian to order the byte within a word, IA32 vs x86
big -> most significant byte has lower address i.e. highest order digit 1 in 0x123456 has lowest address
little -> least significant byte has lower address x86-> little endian 
pointer is a data object that contains an address that you intepret as an address 
boolean in theory is 1 bit but in pratice we address data in 1 byte 

Array represents adjacent locations in memory storing same type of data object

6-10
CSE 351 - showbytes.c print address of pointer + hex representation of the value -1pt
351 - Boolean algebra + bit level manipulating + bitwise operations
DeMorgan's law ~(A|B) = ~A&~B intuition -> flip A/B flip to opposite i.e. ~A -> complement of A , | means 1+0 = 1, & means 1+0 =0 so we flip this rule as well
Bit-level operation
Logic operation -1pt
lab2 -1pt
x86 assembly -1pt


6-11
351 assembly movl %eax, (%edx) -2pts
351 buffer overflow lab3 -3 pts


6-12
351 stack and registers of void swap(int* x, int* y), moving data between registers and memory, 1st addressing mode: movl 12(%ebp), %eax i.e. traversing the offset on the memory side to get the value vs 2nd addressing mode: movl (%eax) %edx i.e. %eax storing the address so go from register side to address of memory side to get the value  - 2pts

Mining Massive Dataset -3pts
-distributed file system, cluster architecture: 1. chunk servers 2.master/name node 3.client library for file access 
-cluster computation challenge: node failure, network bandwidth, complexity -> solution: map-reduce
- e.g. hostname(URL), size -> find the size of paritcular hostname
- e.g. unique word, appearance times
- e.g. count number of times each 5-word sequence occur in a large corpus of documents
map: scan the document once, creates a map of key and value
group by key: sort in order
reduce: reduce/combine the duplicates/multiple occurances into unique occurance result so it can be run in a single node/rack
most examples querying a distributed file system to get a combined result

- link analysis algorithm to compute importances of a node in a graph
- e.g. page rank, hubs and authorities

Reading through quiz - 2pts
 
addressing mode e.g. leal, addl, imul, sall 4(%ecx, %eax) - 1 pt


6-13
351 gdb tutorial -3pt
break main, run, list, disas, step, stepi, help, help info, info registers, x /NUM SIZE FORMAT e.g. x /24wx $rsp i.e. 24 words in hex on the stack 
x /2wx $rdi, x /s $rdi x /x $rsi

phase 1 defused
working on phase 2
target record /target record-full + reverse-step/reverse-next BEFORE step AFTER run -> step back

161- merge sort, 3ways merge sort, x ways merge sort -1pt 
counting no. of inversions - brute force, steps it takes to become sorted array i.e. piggybanking, recursive brute force 

6-14
quick sort vs merge sort, randomized quick sort solving ith statistic element, randomly hoping pivot is going to end up as the ith order element we picked, only one side recursive call depending on which side the ith order is compared to the pivot we choose -3pts

graph vs sorting, social network, google map, course selection, meaningful connection between data not just ranking -2pts 
I still dont understand the number of cuts of n vertices equal to 2^n
right now I am thinking when a new node gets added, it will create an edge with all exist edges so each time the numbers of edges get double when a node is added.
adjacent list, max min amount of edges of n vertices = n-1, n(n-1)/2

DFS, getNeighbours, getVertex, neighbour->visited = true, neighbour->previous = vertC, 2014 mid term followers of followers -1pt


6-15
minimum cut problem - 2pts
if you figure this out, you could become a Stanford PHD.
161-PS3 -1 pt
BFS, DFS, Dijkstra's algo -4pts

DFS - Discovery guarantee to find a path if one exists + D if you apply it since only bactrace
- mark visited, for loop for neighbour node, if stuck backtrace.
Do Fuckup Shit

BFS - cooler than DFS as it will always find the shortest possible path + implementing queue is harder than backtrace, keep track of path by storing predecessor for each vertex, use up more memory assign2 word letter, breadcrump-> breadth = tried every shortest path
- queue, mark visited + set n's previous to be v (breadcrumb), for loop for neighbour node + enqueue, dequeue
Being Fucking Smart

Dijkstra's algo - Cooler than B cause you get a Turing Award, minimum weight path of graph -> create a table of information about currrently known best way to reach each vertex
mark visited + pqueue + weight

going through all the nodes, keep updating the shortest path to the nodes, if you are in the queue then you are waiting for updates on your minimum cost, if you are dequeued then it is confirmed that it is your minimum cost , if you are enqueue then it is the first time you are considered for minimum cost

priotiy queue can guarantee it is the shortest path when you dequeue for 2 reasons: 
1. the first node in the pqueue is guaranteed to be the shortest path to that node as all other indirect paths have at least higher cost 
2. it guarantees it updates the shortest path before dequeuing it as it consider all other shortest paths including its indirect path before considering dequeuing it

prime example of greedy algo


6-16
161 forum post - algo in real world - 1pt
forum post -PA1 -1 pt
228 PA1 - 3pts


6-17
EVERYTHING NORMALIZE BECOME PROBABILITY
WHAT and WHY PGM - conceptual intuition
FRONTEND of probability + independent of algo i.e. you wont learn any algo + modeling a world of uncertainties   

PGM - model, graphical models, random variables that represents probabilities, bayesian network-> directed graph


PGM is a framework -> very large amount of variables + significantly uncertain about the right answer to the result

Model-> declaration representation of understanding of the world, representation of computer that captures our understanding the world in terms of variables and their relationship

Think of the world as a large amount of random variables -> model relationship with joint distribution over possible assignment of certain random variables

Joint distribution: P(x_1, x_2, .... x_n) -> huge possible states, intrinsically exponentially large, ALSO think of it as a table e.g. intelligence, difficulty, grades -> probailitity of every combinations of these 3 random varaibles 

Independent parameter -> values are not determined by other parameters

Conditioning/observing assignment of Grade A -> eliminate all possible assignments of Grade B/C + normalizing/rebase aka reduced probability distribution

Marginalize -> getting rid of intelligence just sum up according to distribution over 

Factor -> a function or a table (x_1, x_2, ...x_n) take all possible assignments in cross-product space i.e. all possible combination of assignments -> gives a real value for each combination 
e.g. joint distribution is a factor a table fo random varaibles
e.g. CPD is a factor
Scope of the factors -> (x_1, x_2, ... x_n) i.e. arguments the factors takes

Factor product -> conditional probability
Factor maginalization -> same
Factor reduction -> same delete + renormalize


Bae's network -> random variables are represented by nodes

Mark's network -> 

Matlab PA1 FactorTutorial.m -2 pts
- implement factor data structure
- AssignmentToIndex([1,2,1],[2,2,2]) //index is 3, [1,1,1] index is 1, [2,1,2] index is 2 etc
- IndexToAssignment(7,[2,2,2]) //1,2,2
- GetValueofAssignment
- SetValueOfAssignment(misspellCar, [1 2 1],6)

PA2 - 2pts
PA3 -1pt


6-18

Structure CPD -1pt
Tabular representation - naive representation over parents I, D and child G, but real world many factors could cause grades or cough, no. of parents of CPD grows exponentially

Dynamic Bayesian Network -1pt
Distribution over trajectory 
Markov assumption - 
Semi markov model 
Template transition model 
Ground Bayesian Network/2 time slice Bayesian Network 

Contextual specific indepedence -

Conditional Independence in bayesian network + navie bayes -1pt



Markov random fields
- pairwise markov networks 
	>> affinity functions, combatabiility function, soft constraints
	>> local happiness to take a particular joint assignments




6-20
PGM PA3 -2pts

RunInference.m
Pairwise, triplet factors 
Similarity factor 


PA4 - 1pt
Belief Propagation message passing in cluster graph - 1pt
Clique Tree - Family Preservation + running intersection property -1pt
PA4 walkthrough by TA -1pt

6-21
PA4 -forum -2pts
Java import java.io.*; library-> package -> class -> methods -> properties -1pt
taxCalculator -1pt 
calendar class -1pt
106a array -1pt

6-22
1. create ec2 instance
choose EC2, create key pair, choose ubuntu as server for configuration, launch new t1-micro instance and get an instance number, go to EC2 dashboard instance get the hostname of remote machine you launched, amazon assigned a IP address and hostname to you and respond to your request with key pair

2. connect to instance    
connect with a standalone SSH client-> chmod 400 key-pair.pem-> access through public DNS/hostname
e.g. ssh -i key-pair.pem root@hostname-amazonaws.com


start up engineering hw2-1pt
done start up engineering -1pt
cache lab -1pt
15-213 triple for loop in c to represent matrix multiplication -1pt


6-22
java array-1pt
andriod activity cycle -2pts
purple rain -3pts
graphics + arraylist to creates random raindrop + recursion does not work since will only copy itself + GOval object will store the number of moves + raindrops = addRainDrops + tick = 0, tick++, if tick % 10 == 0 + RandomGenerator.getinstance().nextint(0,getWidth()); + GOval(x, y, DROP_SIZE, DROP_SIZE) + public GOval addraindrop(){return raindrop} raindrop.move(0,2)  

setup node in ams -1pt
cyberport server

Silicon Valley: system architecture, networking, security, getting root access to NSA servers, database rollback

Reading design decisions -> 2 pts

pointer arithmetic, type casting, malloc, realloc, free, sbrk, brk, mmap, memmove, memset-> 12 pts
open(), strdup(), typedef. 
int putchar(int c) // putc(c, stdout)
int fputc(int c, FILE* stream); // writes the character, cast unsigned char to stream
int putc(intc, FILE* stream);

 

